<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Simulating the Geometric distribution in constant time | Matthijs Muis</title> <meta name="author" content="Matthijs Muis"> <meta name="description" content="Using bitwise integer arithmetic instructions and Diadic rationals."> <meta name="keywords" content="Undergraduate student Mathematics, Computer Science, Radboud University Nijmegen, Portfolio, Teaching, Blog"> <meta property="og:site_name" content="Matthijs Muis"> <meta property="og:type" content="article"> <meta property="og:title" content="Matthijs Muis | Simulating the Geometric distribution in constant time"> <meta property="og:url" content="https://matthijsmu.github.io/blog/2023/simulating-geometric-distribution/"> <meta property="og:description" content="Using bitwise integer arithmetic instructions and Diadic rationals."> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Simulating the Geometric distribution in constant time"> <meta name="twitter:description" content="Using bitwise integer arithmetic instructions and Diadic rationals."> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://matthijsmu.github.io/blog/2023/simulating-geometric-distribution/"> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Matthijs </span>Muis</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"></a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Research</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">Publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">Projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/blog/">Blog</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/repositories/">Repositories</a> </div> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/teaching/">University Courses</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/bijles/">Bijles (NL)</a> </div> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Simulating the Geometric distribution in constant time</h1> <p class="post-meta">August 4, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/category/statistics"> <i class="fas fa-tag fa-sm"></i> statistics,</a>   <a href="/blog/category/algorithms"> <i class="fas fa-tag fa-sm"></i> algorithms</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>On my morning run today I was wondering whether there are faster ways to implement a random generator that samples from a geometric distribution. The naive way is to perform Bernoulli-experiments using uniform distributions until the first success occurs, but this seemed to me hideously expensive as most information of one Bernoulli simulation is thrown away and you could probably do this using some kind of bitwise integer arithmetic. I came up with something and I want to use this post to discuss it with you and establish a connection with simulating the continuous relative of the geometric distribution, that is, the exponential distribution.</p> <hr> <h2 id="the-geometric-distribution">The Geometric distribution</h2> <p>If \(X_1, X_2, ...\) is an infinite sequence of independently Bernoulli\((p)\)-distributed random variables, then we call \(T_1 := min \{k\in \mathbb N_{\geq 1} \mid X_1 = 1 \}\) geometrically distributed, \(T_1 \sim \text{geom}(p)\).</p> <p>We can interpret \(T_n\) as the number of experiments needed for the first “success” (\(X_i = 1\)) to occur.</p> <p>Using independence of the \(X_i\), we can derive \(\mathbb P[T_1 = k] = ppq^{k-1}\) where \(q = 1-p\).</p> <h2 id="simulating-it-the-textbook-way">Simulating it the textbook way</h2> <p>The naive way of thinking is: If we can simulate a \(X_i \sim \text{Bernoulli}(p)\), then we can use that simulator to simulate a \(X \sim \text{geom}(p)\) by just repeatedly simulating \(X\) until a first success occurs, and counting the total number of experiments that we did.</p> <p>The basic (pseudo-) random number generating capabilities that are included in general-purpose programming language such as <code class="language-plaintext highlighter-rouge">C++</code> are:</p> <ul> <li>a simulator for random integers, which generates a random <code class="language-plaintext highlighter-rouge">int</code> value in the range [<code class="language-plaintext highlighter-rouge">MIN_INT</code>, <code class="language-plaintext highlighter-rouge">MAX_INT</code>].</li> <li>a simulator for the \(\text{uniform}[0,1]\)-distribution, which picks a floating-point type value uniformly random from the range \([0,1]\)</li> </ul> <p>The second capability is usually given as the basis for a \(\text{Bernoulli}(p)\)-generator. Observe that if \(U \sim \text{uniform}[0,1]\), then \(\mathbb P [U \leq p] = p\) exactly, so we get the following very simple procedure:</p> <h2 id="my-problem-with-this-approach--my-alternative">My problem with this approach + my alternative</h2> <p>If you think about the above algorithm in terms of what is happening on the hardware level, you quickly realize that it does way too much work.</p> <ul> <li>Random number generators <a href="https://en.wikipedia.org/wiki/Random_number_generation#Uniform_distributions" rel="external nofollow noopener" target="_blank">natively work with integral types</a>. So generating a <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>, etcetera from the range \([0,1]\) consists actually of two steps: first, generate a random <code class="language-plaintext highlighter-rouge">unsigned_integral</code> type value and then divide by <code class="language-plaintext highlighter-rouge">MAX_unsigned_integral</code>.</li> <li>Division is expensive, for one. Also we need something much simpler: we just need a <code class="language-plaintext highlighter-rouge">0</code> with probability \(q\) and a <code class="language-plaintext highlighter-rouge">1</code> with probability \(p\).</li> </ul> <p>Let me just jump to my own idea because the above arguments only make sense when I show you a better implementation to compare against.</p> <h2 id="the-bits-of-random-integers-are-bernoulli-experiments">The bits of random integers are bernoulli experiments</h2> <p>The key point is that if we have an 64-bit <code class="language-plaintext highlighter-rouge">int_A</code> \(\sim\) <code class="language-plaintext highlighter-rouge">random_int()</code>, then all its bits, which I will denote as <code class="language-plaintext highlighter-rouge">int_A[i]</code>, like the integer is some sort of array of booleans, then all bitstrings <code class="language-plaintext highlighter-rouge">int_A[0], ... , int_A[63]</code> are equally likely to occur. This since they all correspond to a unique integer <code class="language-plaintext highlighter-rouge">int_A</code>, and all integer values should by definition of <code class="language-plaintext highlighter-rouge">random_int()</code> occur equally likely.</p> <p>If we marginalize to the distribution of a single <code class="language-plaintext highlighter-rouge">int_A[i]</code>, we realize that it must have a \(\text{Bernoulli}(\frac12)\)-distribution. So when we simulate a random 64-bit integer, we actually get information worth 64 i.i.d. samples from a \(\text{Bernoulli}(\frac12)\)-distribution. This is what I meant when I said that it is a huge detour to first generate a random <code class="language-plaintext highlighter-rouge">int</code>, then divide to a floating-point type in the range \([0,1]\) and only then decide, on 64 bits of information and two expensive arithmetic instructions (floating-point division <em>and</em> floating-point comparison), whether a coin toss is a 0 or a 1.</p> <h2 id="using-bitwise-instructions-to-make-it-even-faster">Using bitwise instructions to make it even faster</h2> <p>With 64 \(\text{Bernoulli}(\frac12)\)-samples in one random number generation, we are left with the task of counting the longest initial segment of failures before a success.</p> <p>The next great feature of integers is that modern CPU architectures come with ALUs that have all kinds of specific circuits for bitwise operations, meaning that manipulating the bits in an integer can be done with dedicated constant-time instructions. For a nice overview, see for example the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="external nofollow noopener" target="_blank">Bitwise Operations</a>.</p> <p>Chess engines, for example make heavy use of such cheap bitwise operations when generating moves. They store the positions of one piece type in 64-bit integers called <code class="language-plaintext highlighter-rouge">bitboard</code>s and when they need to calculate all possible fields that, say a bishop, can move to, they take a 64-bit integer which has <code class="language-plaintext highlighter-rouge">1</code>s on the bishop’s rays, shift it so that the bishop is at the center of the “rose”, perform a bitwise <code class="language-plaintext highlighter-rouge">and</code> with the <code class="language-plaintext highlighter-rouge">or</code> of all other pieces, to “mask” out the “blockers”. The blockers-<code class="language-plaintext highlighter-rouge">bitboard</code> is then used as an index in a lookup table that shows the rays of squares onto which the bishop can actually move. And often, it is cheaper to use a hash of the blockers-<code class="language-plaintext highlighter-rouge">bitboard</code> as there are more possible blocker configurations than movement configurations. And this is, in very simple terms, what they mean with “magic bitboards”.</p> <p>In order to compute the square index (that is, the bit 0-63) at which we have the first occurence of a piece, there is the <code class="language-plaintext highlighter-rouge">ctz</code> or count-zero instruction, which computes the number of trailing zeroes starting from the least significant bit. The <code class="language-plaintext highlighter-rouge">ctz</code>-instruction is exactly what we need to compute the initial number of failures!</p> <p>If the instrcution is directly implemented in the hardware, we can regard it as practically constant-time (although on the hardware level, the time theoretically still depends on the actual number of initial zeroes!). In that case we have achieved the following cheap implementation of a random-\(\text{geometric}(p)\)-generator:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstlib&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="n">SEQUENCE_LENGTH</span> <span class="o">=</span> <span class="n">CHAR_BIT</span> <span class="o">*</span> <span class="nf">max</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(),</span> <span class="k">sizeof</span><span class="p">());</span>

<span class="kt">int</span> <span class="nf">random_geometric</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">SEQUENCE_LENGTH</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>If <code class="language-plaintext highlighter-rouge">seq == 0</code>, we have only failures. This means that the first 64, 48 or 32 experiments (depending on the number of bits <code class="language-plaintext highlighter-rouge">int</code> can contain and the number of bits <code class="language-plaintext highlighter-rouge">std::rand()</code> generates), failed and we have to add 64/48/32 to <code class="language-plaintext highlighter-rouge">x</code> and generate the next sequence of experiments (i.e. the next random integer).</p> <p>Note that calling <code class="language-plaintext highlighter-rouge">std::rand</code> might actually not populate the entire <code class="language-plaintext highlighter-rouge">int</code> if <code class="language-plaintext highlighter-rouge">std::rand()</code> generates shorter integers than the <code class="language-plaintext highlighter-rouge">int</code>-type defined on the machine. Or, the other way around, it might actually generate a longer bitstring and part of this is cut off. In either way, we need that the actual sequence of bernoulli-experiments resides in the shortest of <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">std::rand()</code>, so we know the length of the sequence is the minimum of those lengths. We can compute the length of <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">std::rand()</code> by taking the <code class="language-plaintext highlighter-rouge">sizeof()</code> operator. This returns the size in <em>bytes</em>. But “depending on the computer architecture, a byte may consist of 8 or more bits, the exact number being recorded in CHAR_BIT.” (<a href="https://en.cppreference.com/w/cpp/language/sizeof" rel="external nofollow noopener" target="_blank">cppreference</a>, 2023)</p> <p>The extra condition <code class="language-plaintext highlighter-rouge">seq == 0</code> is of course almost never met: the probability of more than \(N\) failures is namely:</p> \[\mathbb P [X &gt; N] = 1 - \sum_{n=0}^N pq^n = p\cdot \frac {1-q^{N+1}}{1-q} = 1 - q^{N+1}\] </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/mgf-and-discrete-sv/">Moment-Generating Functions for some discrete s.v.'s</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/logic-model-theory/">Logic, Models, Proofs</a> </li> </div> </div> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> © Copyright 2023 Matthijs Muis. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: August 30, 2023. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>