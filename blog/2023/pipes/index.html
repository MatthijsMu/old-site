<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="introduction-chaining-commands-in-bash">Introduction: chaining commands in <code class="language-plaintext highlighter-rouge">bash</code> </h2> <p>In <code class="language-plaintext highlighter-rouge">bash</code>, we can chain commands, for example</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">date</span> | <span class="nb">tail</span> <span class="nt">-c</span> 5
</code></pre></div></div> <p>will redirect the stdout of the <code class="language-plaintext highlighter-rouge">date</code> command to the stdin of <code class="language-plaintext highlighter-rouge">tail -c 5</code>, and this will take the last 5 characters from its stdin stream (including the newline character <code class="language-plaintext highlighter-rouge">\n</code>) and display these to its stdout.</p> <p>More specifically, every command in the pipeline is run in a separate process, and their standard inputs and outputs are connected via a pipe. See <a href="https://www.gnu.org/software/bash/manual/bash.html#Pipelines" rel="external nofollow noopener" target="_blank">GNUs bash manual</a> for the details.</p> <p>Pipes are constructs created and managed by the operating system. On unix-like operating systems, they are created with the system call <code class="language-plaintext highlighter-rouge">pipe()</code>.</p> <p>This post will look into an implementation of a simple shell in <code class="language-plaintext highlighter-rouge">c++</code> that supports chaining of commands and redirection of input/output streams of the first/last command in the chain.</p> <h2 id="file-descriptors">File descriptors</h2> <p>In the POSIX API, files and other IO resources are identified by a <em>file descriptor</em>, which is a process-unique identifier or handle, in <code class="language-plaintext highlighter-rouge">c/c++</code> usually an <code class="language-plaintext highlighter-rouge">int</code>-type.</p> <p>Such a file descriptor can be used as an argument to a <code class="language-plaintext highlighter-rouge">read()</code> or <code class="language-plaintext highlighter-rouge">write()</code> system call, which will result in an actual read or write to the file described by the fd.</p> <p>In the POSIX API, other IO resources are also described by file descriptor, and they can be passed around to the calls <code class="language-plaintext highlighter-rouge">read()</code>, <code class="language-plaintext highlighter-rouge">write()</code>, just as files. So pipes, devices, files, network sockets, all have the same uniform interface for programmers programming to the API.</p> <p>Every process should have access to three standard POSIX file descriptors at any time: <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, and <code class="language-plaintext highlighter-rouge">stderr</code>. <code class="language-plaintext highlighter-rouge">stdin</code> is the fd for the standard input stream, <code class="language-plaintext highlighter-rouge">stdout</code> for the standard output stream and <code class="language-plaintext highlighter-rouge">stderr</code> for the error stream, where errors are printed to if they occur.</p> <p>When programming in a specific language, one has access to the POSIX API via a <em>library</em>, which is the language’s concrete interface to the API. IN <code class="language-plaintext highlighter-rouge">c/c++</code>, this library is <code class="language-plaintext highlighter-rouge">libc</code> and its functions can be found in a collection of header files. The constant file descriptors for <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, and <code class="language-plaintext highlighter-rouge">stderr</code> are available and can be found as <code class="language-plaintext highlighter-rouge">STDIN_FILENO</code>, <code class="language-plaintext highlighter-rouge">STDOUT_FILENO</code> and <code class="language-plaintext highlighter-rouge">STDERR_FILENO</code> in the header <code class="language-plaintext highlighter-rouge">unistd.h</code></p> <p>One advantage of the uniform interface of fds describing IO resources, is that any type of output stream can be redirected to any other type of output stream, and the same goes for input streams. On POSIX we can find the system call <code class="language-plaintext highlighter-rouge">dup2()</code> that does exactly this. For example, suppose we want to redirect the stdout to a file at path <code class="language-plaintext highlighter-rouge">"relative/path/to/your/file.txt"</code>. This can be accomplished by:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file_path</span> <span class="o">=</span> <span class="s">"relative/path/to/your/file.txt"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">;</span>

    <span class="c1">// Open the file in append and write-only mode</span>
    <span class="n">file_descriptor</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_APPEND</span><span class="p">);</span>

    <span class="c1">// If there was an error, open will return -1, otherwise</span>
    <span class="c1">// a valid file descriptor.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file_descriptor</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Error opening the file"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <h2 id="anonymous-pipes">(Anonymous) Pipes</h2> <p>Pipes are file descriptors that can be used for inter-process communication. A pipe is created using the system call <code class="language-plaintext highlighter-rouge">pipe(int pipefd[2])</code>, which populates an array of 2 <code class="language-plaintext highlighter-rouge">int</code>s:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">);</span> <span class="c1">// if error, err = -1</span>
</code></pre></div></div> <p>This pipe has a read end described by <code class="language-plaintext highlighter-rouge">pipefd[0]</code> and a write end described by <code class="language-plaintext highlighter-rouge">pipefd[1]</code>. A pipe can be understood as a buffer in kernel space: all processes for which <code class="language-plaintext highlighter-rouge">pipefd[1]</code> is open, can write to the one end. This stream is buffered until a process begins reading from <code class="language-plaintext highlighter-rouge">pipefd[0]</code>. It is usually advantageous to let processes on both ends run concurrently, so that the buffer is skimmed while being added to and doesn’t grow too long.</p> <p>After a pipe is created, we can <code class="language-plaintext highlighter-rouge">fork()</code> the process. One of the forked processes closes the read end of the pipe and the other closes the write end. We can close resources behind file descriptors with the system call <code class="language-plaintext highlighter-rouge">close(int fd)</code>.</p> <p>Closing unused resources is strictly necessary, because if a write end is still opened in some process, a reading process can never be signalled that the end of a stream is reached (i.e. <code class="language-plaintext highlighter-rouge">read(int fd)</code> will never return <code class="language-plaintext highlighter-rouge">0</code>, but instead will block and a deadlock will occur).</p> <p>The fact that a pipe has only one read end and one write end, and communication streams traverse the pipe from write to read, makes the anonymous pipe <em>unidirectional</em>. It usually only makes sense to have each end opened in only one process simultaneously.</p> <h2 id="prototypical-implementation-of-date--tail--c-5">Prototypical implementation of <code class="language-plaintext highlighter-rouge">date | tail -c 5</code> </h2> <p>Let us motivate the above theory with an example implementation of the command described earlier: <code class="language-plaintext highlighter-rouge">date | tail -c 5</code>. Here is the function in <code class="language-plaintext highlighter-rouge">c++</code> that will do this:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// imports omitted for brevity</span>

<span class="c1">// framework for executing "date | tail -c 5" using raw commands</span>
<span class="c1">// two processes are created, and connected to each other</span>
<span class="kt">int</span> <span class="nf">step1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// create pipe that will (by forking) become a communication channel</span>
  <span class="c1">// between the two children of this process</span>
  <span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error: could not open pipe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">pid_t</span> <span class="n">child1</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
  <span class="c1">// from here, code is executed in two different processes</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">child1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// redirect standard output (STDOUT_FILENO) to the input of the pipe</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
    
    <span class="c1">// free non used resources (why?)</span>
    <span class="c1">// If we do not close the ends of the pipe in a process that won't use them,</span>
    <span class="c1">// the reading process will not detect end-of-files, and the program will </span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> 
    
    <span class="n">Command</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">;</span>
    <span class="n">execute_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
    <span class="c1">// display nice warning that the executable could not be found</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error: could not find executable: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"date"</span><span class="p">);</span>
    <span class="n">abort</span><span class="p">();</span> <span class="c1">// if the executable is not found, we should abort. (why?)</span>
    <span class="c1">// because otherwise the child process will leave the `if`-block and</span>
    <span class="c1">// continues with the control flow that is reserved for the parent process only</span>
    <span class="c1">// (forking another child etc.)</span>
  <span class="p">}</span>

  <span class="c1">// since the child does not exit the `if`-statement, the next fork()</span>
  <span class="c1">// is only executed by the parent.</span>
  <span class="n">pid_t</span> <span class="n">child2</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">child2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// redirect the output of the pipe to the standard input (STDIN_FILENO).</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">);</span>
    
    <span class="c1">// free non used resources </span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    
    
    <span class="c1">// a system call for executing the command "tail -c 5"</span>
    <span class="n">execvp</span><span class="p">(</span><span class="s">"tail -c 5"</span><span class="p">);</span>
    <span class="c1">// display nice warning that the executable could not be found</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error: could not find executable:%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"tail -c 5"</span><span class="p">);</span>
    <span class="n">abort</span><span class="p">();</span> 
  <span class="p">}</span>

  <span class="c1">// free non used resources (why?)</span>
  <span class="c1">// If we do not close the ends of the pipe in a process that won't use them,</span>
  <span class="c1">// the reading process will not detect end-of-files, and the program will </span>
  <span class="c1">// hang.</span>
  <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  
  <span class="c1">// wait on child processes to finish (why both?)</span>
  <span class="c1">// According to manual </span>
  <span class="c1">//    "In the case of a terminated child, performing a wait allows</span>
  <span class="c1">//     the system to release the resources associated with  the  child;  if  a</span>
  <span class="c1">//     wait  is not performed, then the terminated child remains in a "zombie"</span>
  <span class="c1">//     state (see NOTES below)."</span>
  <span class="c1">// So it is to ensure that the child processes actually finished.</span>
  <span class="n">waitpid</span><span class="p">(</span><span class="n">child1</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">waitpid</span><span class="p">(</span><span class="n">child2</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div> <p>There are three other system calls that enter the play: <code class="language-plaintext highlighter-rouge">fork()</code>, <code class="language-plaintext highlighter-rouge">waitpid()</code> and <code class="language-plaintext highlighter-rouge">execvp()</code>. Forking will create new processes that each execute one of the chained commands</p> <h3 id="fork"><code class="language-plaintext highlighter-rouge">fork()</code></h3> <p>We use the system call <code class="language-plaintext highlighter-rouge">fork()</code> to fork a process. This will clone the memory (text, data, heap, stack, CPU state, open files and in fact the entire process control block) of a process, creating two processes that are completely identical but for their process id. Note that in practice, a copy of the process’ memory and PCB may only be made once one of the forked processes begins writing to parts of this memory (known as a copy-on-write mechanism), avoiding a lot of overhead that would be incurred from copying memory.</p> <p>One of the processes can be seen as “newer” in the sense that it has received a new process id. This process is referred to as the <code class="language-plaintext highlighter-rouge">child</code> process, the pre-existing process we call the parent. After the <code class="language-plaintext highlighter-rouge">fork()</code>, all remaining code (compiled as machine code) will be run in two processes separately and concurrently. Since the process control block is also copied</p> <p>The <code class="language-plaintext highlighter-rouge">fork()</code> system call will return a <code class="language-plaintext highlighter-rouge">pid_t</code> (process-id type) identifier. This return value is different for the two processes, and is the only way that the code can understand and control in which process it is being run. We can for example run a branch of code conditionally on <code class="language-plaintext highlighter-rouge">if ((int child_id = fork()) != 0) { ... }</code>, which will ensure that the code after the <code class="language-plaintext highlighter-rouge">if</code> is only run in the child process, while the parent process can go on with something else.</p> <h3 id="waitpid"><code class="language-plaintext highlighter-rouge">waitpid()</code></h3> <p>The parent process can wait for the child process to change state using the system call <code class="language-plaintext highlighter-rouge">waidpid()</code>. According to <code class="language-plaintext highlighter-rouge">man</code> the state changes are: terminate, stopped by a signal or resumed by a signal.</p> <h3 id="execvp"><code class="language-plaintext highlighter-rouge">execvp()</code></h3> <p>According to the <code class="language-plaintext highlighter-rouge">man</code>-pages,</p> <blockquote> <p>“The exec() family of functions replaces the current process image with a new process image.”</p> </blockquote> <p>meaning that the entire image (including machine code (.text), stack, .data, heap, .bss ) is replaced by another executable image. So if everything goes right, we never return from the function <code class="language-plaintext highlighter-rouge">execvp()</code> and all code after the <code class="language-plaintext highlighter-rouge">execvp()</code> line is never reached. If <code class="language-plaintext highlighter-rouge">execvp()</code> fails, we do return and have to abort the child process gracefully (if we don’t abort, the waiting parent will hang).</p> <p><code class="language-plaintext highlighter-rouge">execvp(char *const argv[])</code> calls a program with an array <code class="language-plaintext highlighter-rouge">argv</code> of pointers to null-terminated strings. The first argument is the name of the program, the following arguments are arguments to the program.</p> <h3 id="the-piping-construct">The piping construct</h3> <p>Note that we first create a pipe, then clone the process. There is still but one pipe, pointed to by file descriptors present in both the parent and two children. Remember that a child inherits open files from its parent, because its PCB is simply a clone of its parent’s PCB, and the PCB contains the list of open files. All processes that will not use the write end of the pipe must close it, and the same goes for the read end of the pipe, and all other open non-constant (i.e. <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stderr</code>) file descriptors that are not used in that particular process.</p> <p>Next, using <code class="language-plaintext highlighter-rouge">dup2()</code> the first child will redirect the <code class="language-plaintext highlighter-rouge">stdout</code> to the write end of the pipe. In the branch executed by the second child, we do the same with the read end and <code class="language-plaintext highlighter-rouge">stdin</code>.</p> <p>Having configured the in- and outstreams appropriately, we call <code class="language-plaintext highlighter-rouge">execvp()</code> in both children, and abort if anything goes wrong. The parent needs to wait for all children to finish, just as in an ordinary shell session.</p> <h3 id="whats-next">What’s next</h3> <p>I wanted to discuss an implementation of a very simple shell <code class="language-plaintext highlighter-rouge">shell.cpp</code> that allows chaining using <code class="language-plaintext highlighter-rouge">|</code> and redirections using <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>, but the simple example <code class="language-plaintext highlighter-rouge">step1()</code> and all theory surrounding it has made this post rather lengthy already.</p> <p>That is why there will be a part two, where I will continue and discuss the implementation of this simple shell in a full program named <code class="language-plaintext highlighter-rouge">shell.cpp</code>. Hope to see you there.</p> </body></html>