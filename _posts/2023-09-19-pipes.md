## Introduction: chaining commands in `bash`

In `bash`, we can chain commands, for example  
```bash
date | tail -c 5
```
will redirect the stdout of the `date` command to the stdin of
`tail -c 5`, and this will take the last 5 characters from
its stdin stream (including the newline character `\n`) and
display these to its stdout.

More specifically, every command in the pipeline is run in 
a separate process, and their standard inputs and outputs 
are connected via a pipe. See [GNUs bash manual](https://www.gnu.org/software/bash/manual/bash.html#Pipelines)
for the details.

Pipes are constructs created and managed by the operating 
system. On unix-like operating systems, they are created with
the system call `pipe()`. 

This post will look into an implementation of a simple shell
in `c++` that supports chaining of commands and redirection
of input/output streams of the first/last command in the 
chain. 

## File descriptors

In the POSIX API, files and other IO resources are identified
by a *file descriptor*, which is a process-unique identifier 
or handle, in `c/c++` usually an `int`-type. 

Such a file descriptor can be used as an argument to a `read()`
or `write()` system call, which will result in an actual read
or write to the file described by the fd.

In the POSIX API, other IO resources are also described by
file descriptor, and they can be passed around to the calls
`read()`, `write()`, just as files. So pipes, devices, files,
network sockets, all have the same uniform interface for programmers
programming to the API.

Every process should have access to three standard POSIX file
descriptors at any time: `stdin`, `stdout`, and `stderr`.
`stdin` is the fd for the standard input stream, `stdout` for
the standard output stream and `stderr` for the error stream,
where errors are printed to if they occur.

When programming in a specific language, one has access to 
the POSIX API via a *library*, which is the language's concrete
interface to the API. IN `c/c++`, this library is `libc` and
its functions can be found in a collection of header files.
The constant file descriptors for `stdin`, `stdout`, and `stderr`
are available and can be found as `STDIN_FILENO`, `STDOUT_FILENO`
and `STDERR_FILENO` in the header `unistd.h`

One advantage of the uniform interface of fds describing 
IO resources, is that any type of output stream can be redirected
to any other type of output stream, and the same goes for input
streams. On POSIX we can find the system call `dup2()` that
does exactly this. For example, suppose we want to redirect the
stdout to a file at path `"relative/path/to/your/file.txt"`. This can be accomplished
by:

```c++
    const char *file_path = "relative/path/to/your/file.txt";
    int file_descriptor;

    // Open the file in append and write-only mode
    file_descriptor = open(file_path, O_WRONLY | O_APPEND);

    // If there was an error, open will return -1, otherwise
    // a valid file descriptor.
    if (file_descriptor == -1) {
        perror("Error opening the file");
        exit(EXIT_FAILURE);
    } else {
        dup2(file_descriptor, STDOUT_FILENO);
    }
```

## (Anonymous) Pipes

Pipes are file descriptors that can be used for inter-process
communication. A pipe is created using the system call 
`pipe(int pipefd[2])`, which populates an array of 2 `int`s:

```c++
int pipefd[2];
int err = pipe(pipefd); // if error, err = -1
```

This pipe has a read end described by `pipefd[0]` and a
write end described by `pipefd[1]`. A pipe can be understood
as a buffer in kernel space: all processes for which 
`pipefd[1]` is open, can write to the one end. This stream 
is buffered until a process begins reading from `pipefd[0]`.
It is usually advantageous to let processes on both ends run
concurrently, so that the buffer is skimmed while being added
to and doesn't grow too long.


After a pipe is created, we can `fork()` the process. One of
the forked processes closes the read end of the pipe and the
other closes the write end. We can close resources behind
 file descriptors with the 
system call `close(int fd)`. 

Closing unused resources is
strictly necessary, because if a write end is still opened in some
process, a reading process can never be signalled that the
end of a stream is reached (i.e. `read(int fd)` will never
return `0`, but instead will block and a deadlock will occur).

The fact that a pipe has only one read end and one write end, 
and communication streams traverse the pipe from write to
read, makes the anonymous pipe *unidirectional*. It usually
only makes sense to have each end opened in only one process
simultaneously.

## Prototypical implementation of `date | tail -c 5`

Let us motivate the above theory with an example implementation
of the command described earlier: `date | tail -c 5`. Here is 
the function in `c++` that will do this:

```c++
// imports omitted for brevity

// framework for executing "date | tail -c 5" using raw commands
// two processes are created, and connected to each other
int step1(void) {

  // create pipe that will (by forking) become a communication channel
  // between the two children of this process
  int pipefd[2];
  
  if (pipe(pipefd) < 0) {
    printf("error: could not open pipe\n");
    exit(1);
  }

  pid_t child1 = fork();
  // from here, code is executed in two different processes
  if (child1 == 0) {
    // redirect standard output (STDOUT_FILENO) to the input of the pipe
    dup2(pipefd[1], STDOUT_FILENO);
    
    // free non used resources (why?)
    // If we do not close the ends of the pipe in a process that won't use them,
    // the reading process will not detect end-of-files, and the program will 
    close(pipefd[0]); 
    
    Command cmd = {{string("date")}};
    execute_command(cmd);
    // display nice warning that the executable could not be found
    printf("error: could not find executable: %s\n", "date");
    abort(); // if the executable is not found, we should abort. (why?)
    // because otherwise the child process will leave the `if`-block and
    // continues with the control flow that is reserved for the parent process only
    // (forking another child etc.)
  }

  // since the child does not exit the `if`-statement, the next fork()
  // is only executed by the parent.
  pid_t child2 = fork();
  if (child2 == 0) {
    // redirect the output of the pipe to the standard input (STDIN_FILENO).
    dup2(pipefd[0], STDIN_FILENO);
    
    // free non used resources 
    close(pipefd[1]);
    
    
    // a system call for executing the command "tail -c 5"
    execvp("tail -c 5");
    // display nice warning that the executable could not be found
    printf("error: could not find executable:%s\n", "tail -c 5");
    abort(); 
  }

  // free non used resources (why?)
  // If we do not close the ends of the pipe in a process that won't use them,
  // the reading process will not detect end-of-files, and the program will 
  // hang.
  close(pipefd[0]);
  close(pipefd[1]);
  
  // wait on child processes to finish (why both?)
  // According to manual 
  //    "In the case of a terminated child, performing a wait allows
  //     the system to release the resources associated with  the  child;  if  a
  //     wait  is not performed, then the terminated child remains in a "zombie"
  //     state (see NOTES below)."
  // So it is to ensure that the child processes actually finished.
  waitpid(child1, nullptr, 0);
  waitpid(child2, nullptr, 0);
  return 0;
}

```
There are three other system calls that enter the play: `fork()`, 
`waitpid()` and `execvp()`.
Forking will create new processes that each execute one of the chained commands


### `fork()`

We use the system call `fork()` to fork a process. This will
clone the memory (text, data, heap, stack, CPU state, open 
files and in 
fact the entire process control block) of a process, creating 
two processes that are completely identical but for their
process id. Note that in practice, a copy of the process' memory
and PCB may only be made once one of the forked processes
begins writing to parts of this memory (known as a copy-on-write mechanism),
avoiding a lot of overhead that would be incurred from copying memory.

One of the processes can be seen as "newer" in 
the sense that it has received a new process id. This process
is referred to as the `child` process, the pre-existing process
we call the parent. After the `fork()`, all remaining code
(compiled as machine code) will be run in two processes
separately and concurrently. Since the process control block is
also copied 

The `fork()` system call will return a 
`pid_t` (process-id type) identifier. This return value is
different for the two processes, and is the only way that
the code can understand and control in which process it is being run.
We can for example run a branch of code conditionally on
`if ((int child_id = fork()) != 0) { ... }`, which will ensure
that the code after the `if` is only run in the child process,
while the parent process can go on with something else.

### `waitpid()`

The parent process can wait for the child process to change
state using the system call `waidpid()`. According to `man` the state changes are:
 terminate, stopped by a signal
or resumed by a signal.

### `execvp()`

According to the `man`-pages, 

> "The exec() family of functions replaces the current process image with a new process image."

meaning that the entire image (including machine code (.text), stack, .data, heap, .bss ) is replaced by another executable image. So if everything goes right, we never return from the 
function `execvp()` and all code after the `execvp()` line is never reached. If `execvp()` fails,
we do return and have to abort the child process gracefully (if we don't abort, the waiting parent
will hang).

`execvp(char *const argv[])` calls a program with an array `argv` of pointers to null-terminated strings. The first argument is the name of the program, the following arguments are arguments to 
the program.

### The piping construct

Note that we first create a pipe, then clone the process. There is still but one pipe, pointed to 
by file descriptors present in both the parent and two children. 
Remember that a child inherits open files from its parent, because its PCB is simply a clone of its parent's PCB, and the PCB contains the list of open files. All processes that will not use
the write end of the pipe must close it, and the same goes for the read end of the pipe, and all other open non-constant (i.e. `stdout`, `stdin`, `stderr`) file descriptors that are not used in that particular process.

Next, using `dup2()` the first child will redirect the `stdout` to the write end of the pipe. In 
the branch executed by the second child, we do the same with the read end and `stdin`.

Having configured the in- and outstreams appropriately, we call `execvp()` in both children, and 
abort if anything goes wrong. The parent needs to wait for all children to finish, just as in
an ordinary shell session.

### What's next

I wanted to discuss an implementation of a very simple shell `shell.cpp` that allows chaining using `|` and redirections using `<` and `>`, but the simple example `step1()` and all theory surrounding it has
made this post rather lengthy already. 

That is why there will be a part two, where I will continue and
discuss the implementation of this simple shell in a full program named `shell.cpp`. Hope to see
you there.